use std::error::Error;
use crate::methods::{bytes_to_hex, hex_to_bytes};

const S: [u8; 256] = [
    0xFC, 0xEE, 0xDD, 0x11, 0xCF, 0x6E, 0x31, 0x16, 0xFB, 0xC4, 0xFA, 0xDA, 0x23, 0xC5, 0x04, 0x4D,
    0xE9, 0x77, 0xF0, 0xDB, 0x93, 0x2E, 0x99, 0xBA, 0x17, 0x36, 0xF1, 0xBB, 0x14, 0xCD, 0x5F, 0xC1,
    0xF9, 0x18, 0x65, 0x5A, 0xE2, 0x5C, 0xEF, 0x21, 0x81, 0x1C, 0x3C, 0x42, 0x8B, 0x01, 0x8E, 0x4F,
    0x05, 0x84, 0x02, 0xAE, 0xE3, 0x6A, 0x8F, 0xA0, 0x06, 0x0B, 0xED, 0x98, 0x7F, 0xD4, 0xD3, 0x1F,
    0xEB, 0x34, 0x2C, 0x51, 0xEA, 0xC8, 0x48, 0xAB, 0xF2, 0x2A, 0x68, 0xA2, 0xFD, 0x3A, 0xCE, 0xCC,
    0xB5, 0x70, 0x0E, 0x56, 0x08, 0x0C, 0x76, 0x12, 0xBF, 0x72, 0x13, 0x47, 0x9C, 0xB7, 0x5D, 0x87,
    0x15, 0xA1, 0x96, 0x29, 0x10, 0x7B, 0x9A, 0xC7, 0xF3, 0x91, 0x78, 0x6F, 0x9D, 0x9E, 0xB2, 0xB1,
    0x32, 0x75, 0x19, 0x3D, 0xFF, 0x35, 0x8A, 0x7E, 0x6D, 0x54, 0xC6, 0x80, 0xC3, 0xBD, 0x0D, 0x57,
    0xDF, 0xF5, 0x24, 0xA9, 0x3E, 0xA8, 0x43, 0xC9, 0xD7, 0x79, 0xD6, 0xF6, 0x7C, 0x22, 0xB9, 0x03,
    0xE0, 0x0F, 0xEC, 0xDE, 0x7A, 0x94, 0xB0, 0xBC, 0xDC, 0xE8, 0x28, 0x50, 0x4E, 0x33, 0x0A, 0x4A,
    0xA7, 0x97, 0x60, 0x73, 0x1E, 0x00, 0x62, 0x44, 0x1A, 0xB8, 0x38, 0x82, 0x64, 0x9F, 0x26, 0x41,
    0xAD, 0x45, 0x46, 0x92, 0x27, 0x5E, 0x55, 0x2F, 0x8C, 0xA3, 0xA5, 0x7D, 0x69, 0xD5, 0x95, 0x3B,
    0x07, 0x58, 0xB3, 0x40, 0x86, 0xAC, 0x1D, 0xF7, 0x30, 0x37, 0x6B, 0xE4, 0x88, 0xD9, 0xE7, 0x89,
    0xE1, 0x1B, 0x83, 0x49, 0x4C, 0x3F, 0xF8, 0xFE, 0x8D, 0x53, 0xAA, 0x90, 0xCA, 0xD8, 0x85, 0x61,
    0x20, 0x71, 0x67, 0xA4, 0x2D, 0x2B, 0x09, 0x5B, 0xCB, 0x9B, 0x25, 0xD0, 0xBE, 0xE5, 0x6C, 0x52,
    0x59, 0xA6, 0x74, 0xD2, 0xE6, 0xF4, 0xB4, 0xC0, 0xD1, 0x66, 0xAF, 0xC2, 0x39, 0x4B, 0x63, 0xB6
];

const S_REVERSE: [u8; 256] = [
    0xA5, 0x2D, 0x32, 0x8F, 0x0E, 0x30, 0x38, 0xC0, 0x54, 0xE6, 0x9E, 0x39, 0x55, 0x7E, 0x52, 0x91,
    0x64, 0x03, 0x57, 0x5A, 0x1C, 0x60, 0x07, 0x18, 0x21, 0x72, 0xA8, 0xD1, 0x29, 0xC6, 0xA4, 0x3F,
    0xE0, 0x27, 0x8D, 0x0C, 0x82, 0xEA, 0xAE, 0xB4, 0x9A, 0x63, 0x49, 0xE5, 0x42, 0xE4, 0x15, 0xB7,
    0xC8, 0x06, 0x70, 0x9D, 0x41, 0x75, 0x19, 0xC9, 0xAA, 0xFC, 0x4D, 0xBF, 0x2A, 0x73, 0x84, 0xD5,
    0xC3, 0xAF, 0x2B, 0x86, 0xA7, 0xB1, 0xB2, 0x5B, 0x46, 0xD3, 0x9F, 0xFD, 0xD4, 0x0F, 0x9C, 0x2F,
    0x9B, 0x43, 0xEF, 0xD9, 0x79, 0xB6, 0x53, 0x7F, 0xC1, 0xF0, 0x23, 0xE7, 0x25, 0x5E, 0xB5, 0x1E,
    0xA2, 0xDF, 0xA6, 0xFE, 0xAC, 0x22, 0xF9, 0xE2, 0x4A, 0xBC, 0x35, 0xCA, 0xEE, 0x78, 0x05, 0x6B,
    0x51, 0xE1, 0x59, 0xA3, 0xF2, 0x71, 0x56, 0x11, 0x6A, 0x89, 0x94, 0x65, 0x8C, 0xBB, 0x77, 0x3C,
    0x7B, 0x28, 0xAB, 0xD2, 0x31, 0xDE, 0xC4, 0x5F, 0xCC, 0xCF, 0x76, 0x2C, 0xB8, 0xD8, 0x2E, 0x36,
    0xDB, 0x69, 0xB3, 0x14, 0x95, 0xBE, 0x62, 0xA1, 0x3B, 0x16, 0x66, 0xE9, 0x5C, 0x6C, 0x6D, 0xAD,
    0x37, 0x61, 0x4B, 0xB9, 0xE3, 0xBA, 0xF1, 0xA0, 0x85, 0x83, 0xDA, 0x47, 0xC5, 0xB0, 0x33, 0xFA,
    0x96, 0x6F, 0x6E, 0xC2, 0xF6, 0x50, 0xFF, 0x5D, 0xA9, 0x8E, 0x17, 0x1B, 0x97, 0x7D, 0xEC, 0x58,
    0xF7, 0x1F, 0xFB, 0x7C, 0x09, 0x0D, 0x7A, 0x67, 0x45, 0x87, 0xDC, 0xE8, 0x4F, 0x1D, 0x4E, 0x04,
    0xEB, 0xF8, 0xF3, 0x3E, 0x3D, 0xBD, 0x8A, 0x88, 0xDD, 0xCD, 0x0B, 0x13, 0x98, 0x02, 0x93, 0x80,
    0x90, 0xD0, 0x24, 0x34, 0xCB, 0xED, 0xF4, 0xCE, 0x99, 0x10, 0x44, 0x40, 0x92, 0x3A, 0x01, 0x26,
    0x12, 0x1A, 0x48, 0x68, 0xF5, 0x81, 0x8B, 0xC7, 0xD6, 0x20, 0x0A, 0x08, 0x00, 0x4C, 0xD7, 0x74
];

const L_VEC: [u8; 16] = [
    1, 148, 32, 133, 16, 194, 192, 1,
    251, 1, 192, 194, 16, 133, 32, 148
];

const C: [[u8; 16]; 32] = [
    [0x6e, 0xa2, 0x76, 0x72, 0x6c, 0x48, 0x7a, 0xb8, 0x5d, 0x27, 0xbd, 0x10, 0xdd, 0x84, 0x94, 0x01],
    [0xdc, 0x87, 0xec, 0xe4, 0xd8, 0x90, 0xf4, 0xb3, 0xba, 0x4e, 0xb9, 0x20, 0x79, 0xcb, 0xeb, 0x02],
    [0xb2, 0x25, 0x9a, 0x96, 0xb4, 0xd8, 0x8e, 0x0b, 0xe7, 0x69, 0x04, 0x30, 0xa4, 0x4f, 0x7f, 0x03],
    [0x7b, 0xcd, 0x1b, 0x0b, 0x73, 0xe3, 0x2b, 0xa5, 0xb7, 0x9c, 0xb1, 0x40, 0xf2, 0x55, 0x15, 0x04],
    [0x15, 0x6f, 0x6d, 0x79, 0x1f, 0xab, 0x51, 0x1d, 0xea, 0xbb, 0x0c, 0x50, 0x2f, 0xd1, 0x81, 0x05],
    [0xa7, 0x4a, 0xf7, 0xef, 0xab, 0x73, 0xdf, 0x16, 0x0d, 0xd2, 0x08, 0x60, 0x8b, 0x9e, 0xfe, 0x06],
    [0xc9, 0xe8, 0x81, 0x9d, 0xc7, 0x3b, 0xa5, 0xae, 0x50, 0xf5, 0xb5, 0x70, 0x56, 0x1a, 0x6a, 0x07],
    [0xf6, 0x59, 0x36, 0x16, 0xe6, 0x05, 0x56, 0x89, 0xad, 0xfb, 0xa1, 0x80, 0x27, 0xaa, 0x2a, 0x08],
    [0x98, 0xfb, 0x40, 0x64, 0x8a, 0x4d, 0x2c, 0x31, 0xf0, 0xdc, 0x1c, 0x90, 0xfa, 0x2e, 0xbe, 0x09],
    [0x2a, 0xde, 0xda, 0xf2, 0x3e, 0x95, 0xa2, 0x3a, 0x17, 0xb5, 0x18, 0xa0, 0x5e, 0x61, 0xc1, 0x0a],
    [0x44, 0x7c, 0xac, 0x80, 0x52, 0xdd, 0xd8, 0x82, 0x4a, 0x92, 0xa5, 0xb0, 0x83, 0xe5, 0x55, 0x0b],
    [0x8d, 0x94, 0x2d, 0x1d, 0x95, 0xe6, 0x7d, 0x2c, 0x1a, 0x67, 0x10, 0xc0, 0xd5, 0xff, 0x3f, 0x0c],
    [0xe3, 0x36, 0x5b, 0x6f, 0xf9, 0xae, 0x07, 0x94, 0x47, 0x40, 0xad, 0xd0, 0x08, 0x7b, 0xab, 0x0d],
    [0x51, 0x13, 0xc1, 0xf9, 0x4d, 0x76, 0x89, 0x9f, 0xa0, 0x29, 0xa9, 0xe0, 0xac, 0x34, 0xd4, 0x0e],
    [0x3f, 0xb1, 0xb7, 0x8b, 0x21, 0x3e, 0xf3, 0x27, 0xfd, 0x0e, 0x14, 0xf0, 0x71, 0xb0, 0x40, 0x0f],
    [0x2f, 0xb2, 0x6c, 0x2c, 0x0f, 0x0a, 0xac, 0xd1, 0x99, 0x35, 0x81, 0xc3, 0x4e, 0x97, 0x54, 0x10],
    [0x41, 0x10, 0x1a, 0x5e, 0x63, 0x42, 0xd6, 0x69, 0xc4, 0x12, 0x3c, 0xd3, 0x93, 0x13, 0xc0, 0x11],
    [0xf3, 0x35, 0x80, 0xc8, 0xd7, 0x9a, 0x58, 0x62, 0x23, 0x7b, 0x38, 0xe3, 0x37, 0x5c, 0xbf, 0x12],
    [0x9d, 0x97, 0xf6, 0xba, 0xbb, 0xd2, 0x22, 0xda, 0x7e, 0x5c, 0x85, 0xf3, 0xea, 0xd8, 0x2b, 0x13],
    [0x54, 0x7f, 0x77, 0x27, 0x7c, 0xe9, 0x87, 0x74, 0x2e, 0xa9, 0x30, 0x83, 0xbc, 0xc2, 0x41, 0x14],
    [0x3a, 0xdd, 0x01, 0x55, 0x10, 0xa1, 0xfd, 0xcc, 0x73, 0x8e, 0x8d, 0x93, 0x61, 0x46, 0xd5, 0x15],
    [0x88, 0xf8, 0x9b, 0xc3, 0xa4, 0x79, 0x73, 0xc7, 0x94, 0xe7, 0x89, 0xa3, 0xc5, 0x09, 0xaa, 0x16],
    [0xe6, 0x5a, 0xed, 0xb1, 0xc8, 0x31, 0x09, 0x7f, 0xc9, 0xc0, 0x34, 0xb3, 0x18, 0x8d, 0x3e, 0x17],
    [0xd9, 0xeb, 0x5a, 0x3a, 0xe9, 0x0f, 0xfa, 0x58, 0x34, 0xce, 0x20, 0x43, 0x69, 0x3d, 0x7e, 0x18],
    [0xb7, 0x49, 0x2c, 0x48, 0x85, 0x47, 0x80, 0xe0, 0x69, 0xe9, 0x9d, 0x53, 0xb4, 0xb9, 0xea, 0x19],
    [0x05, 0x6c, 0xb6, 0xde, 0x31, 0x9f, 0x0e, 0xeb, 0x8e, 0x80, 0x99, 0x63, 0x10, 0xf6, 0x95, 0x1a],
    [0x6b, 0xce, 0xc0, 0xac, 0x5d, 0xd7, 0x74, 0x53, 0xd3, 0xa7, 0x24, 0x73, 0xcd, 0x72, 0x01, 0x1b],
    [0xa2, 0x26, 0x41, 0x31, 0x9a, 0xec, 0xd1, 0xfd, 0x83, 0x52, 0x91, 0x03, 0x9b, 0x68, 0x6b, 0x1c],
    [0xcc, 0x84, 0x37, 0x43, 0xf6, 0xa4, 0xab, 0x45, 0xde, 0x75, 0x2c, 0x13, 0x46, 0xec, 0xff, 0x1d],
    [0x7e, 0xa1, 0xad, 0xd5, 0x42, 0x7c, 0x25, 0x4e, 0x39, 0x1c, 0x28, 0x23, 0xe2, 0xa3, 0x80, 0x1e],
    [0x10, 0x03, 0xdb, 0xa7, 0x2e, 0x34, 0x5f, 0xf6, 0x64, 0x3b, 0x95, 0x33, 0x3f, 0x27, 0x14, 0x1f],
    [0x5e, 0xa7, 0xd8, 0x58, 0x1e, 0x14, 0x9b, 0x61, 0xf1, 0x6a, 0xc1, 0x45, 0x9c, 0xed, 0xa8, 0x20],
];

fn x(left: &[u8], right: &[u8]) -> Vec<u8> {
    left.iter().zip(right.iter()).map(|(left, right)| *left ^ *right).collect()
}

fn s(part: &[u8]) -> Vec<u8> {
    part.iter().map(|elem| S[*elem as usize]).collect()
}

fn s_reverse(part: &[u8]) -> Vec<u8> {
    part.iter().map(|elem| S_REVERSE[*elem as usize]).collect()
}

fn gf_mul(mut left: u8, mut right: u8) -> u8 {
    let mut result: u8 = 0;
    let mut hi_bit: u8;
    for _ in 0..8 {
        if right & 1 != 0 { result ^= left }
        hi_bit = left & 0x80;
        left <<= 1;
        if hi_bit != 0 { left ^= 0xc3 }
        right >>= 1;
    }
    result
}

fn r(data: &[u8]) -> Vec<u8> {
    let mut result = data[..data.len() - 1].to_vec();
    let mut a_15 = 0_u8;
    for (elem, coef) in data.iter().rev().zip(L_VEC.iter()) {
        a_15 ^= gf_mul(*elem, *coef);
    }
    result.insert(0, a_15);
    result
}

fn r_reverse(data: &[u8]) -> Vec<u8> {
    let mut result = data[1..].to_vec();
    let mut a_0 = 0;
    let mut copy: Vec<u8> = data.to_vec();
    copy.remove(0);
    copy.push(*data.first().unwrap());
    for (elem, coef) in copy.iter().rev().zip(L_VEC.iter()) {
        a_0 ^= gf_mul(*elem, *coef);
    }
    result.push(a_0);
    result
}

fn l<T>(data: &[u8], func: T) -> Vec<u8>
    where T: Fn(&[u8]) -> Vec<u8>
{
    let mut data = data.to_vec();
    for _ in 0..16 {
        data = func(&data);
    }
    data
}

fn f(left: &[u8], right: &[u8], iter_c: &[u8]) -> (Vec<u8>, Vec<u8>) {
    (x(&l(&s(&x(left, iter_c)), r), right), left.to_vec())
}

fn expand_key(key: &[u8]) -> Vec<Vec<u8>> {
    let mut result: Vec<Vec<u8>> = vec![
        key[..16].to_vec(),
        key[16..].to_vec()
    ];
    for i in 0..4_usize {
        let (mut p1, mut p2) = (result.get(i * 2).unwrap().clone(), result.get(i * 2 + 1).unwrap().clone());
        for j in 0..8 {
            (p1, p2) = f(&p1, &p2, &C[i * 8 + j]);
        }
        result.push(p1);
        result.push(p2);
    }
    result
}

fn enc(part: &[u8], keys: &[Vec<u8>]) -> Vec<u8> {
    let mut result = part.to_vec();
    for key in keys[..keys.len()-1].iter() {
        result = l(&s(&x(&result, key)), r);
    }
    result = x(&result, keys.last().unwrap());
    result
}

fn dec(part: &[u8], keys: &[Vec<u8>]) -> Vec<u8> {
    let mut result = part.to_vec();
    for key in keys[1..].iter().rev() {
        result = s_reverse(&l(&x(&result, key), r_reverse));
    }
    result = x(&result, keys.first().unwrap());
    result
}

fn proto<T>(phrase: &str, key: &str, encryption_func: T) -> Result<String, Box<dyn Error>> 
    where T: Fn(&[u8], &[Vec<u8>]) -> Vec<u8>
{
    let phrase = hex_to_bytes(phrase, 16)?;
    let key = hex_to_bytes(key, 32)?;
    let keys = expand_key(&key);
    let mut result: Vec<u8> = Vec::new();
    for segment in phrase.windows(16).step_by(16) {
        result.extend(encryption_func(segment, &keys));
    }
    Ok(bytes_to_hex(&result))
}

pub fn encrypt(phrase: &str, key: &str) -> Result<String, Box<dyn Error>> {
    proto(phrase, key, enc)
}

pub fn decrypt(phrase: &str, key: &str) -> Result<String, Box<dyn Error>> {
    proto(phrase, key, dec)
}

#[cfg(test)]
mod kuznechik_tests {
    use crate::methods::hex_to_bytes;
    use super::*;
    
    #[test]
    fn test_s() {
        let data = [
            hex_to_bytes("ffeeddccbbaa99881122334455667700", 1).unwrap(),
            hex_to_bytes("b66cd8887d38e8d77765aeea0c9a7efc", 1).unwrap(),
            hex_to_bytes("559d8dd7bd06cbfe7e7b262523280d39", 1).unwrap(),
            hex_to_bytes("0c3322fed531e4630d80ef5c5a81c50b", 1).unwrap(),
        ];
        let valid = [
            hex_to_bytes("b66cd8887d38e8d77765aeea0c9a7efc", 1).unwrap(),
            hex_to_bytes("559d8dd7bd06cbfe7e7b262523280d39", 1).unwrap(),
            hex_to_bytes("0c3322fed531e4630d80ef5c5a81c50b", 1).unwrap(),
            hex_to_bytes("23ae65633f842d29c5df529c13f5acda", 1).unwrap(),
        ];
        for (data, valid) in data.iter().zip(valid.iter()) {
            assert_eq!(s(data), *valid);
        }
    }

    #[test]
    fn test_r() {
        let data = [
            hex_to_bytes("00000000000000000000000000000100", 1).unwrap(),
            hex_to_bytes("94000000000000000000000000000001", 1).unwrap(),
            hex_to_bytes("a5940000000000000000000000000000", 1).unwrap(),
            hex_to_bytes("64a59400000000000000000000000000", 1).unwrap(),
        ];
        let valid = [
            hex_to_bytes("94000000000000000000000000000001", 1).unwrap(),
            hex_to_bytes("a5940000000000000000000000000000", 1).unwrap(),
            hex_to_bytes("64a59400000000000000000000000000", 1).unwrap(),
            hex_to_bytes("0d64a594000000000000000000000000", 1).unwrap(),
        ];
        for (data, valid) in data.iter().zip(valid.iter()) {
            assert_eq!(r(data), *valid);
        }
    }

    #[test]
    fn test_r_reverse() {
        let data = [
            hex_to_bytes("94000000000000000000000000000001", 1).unwrap(),
            hex_to_bytes("a5940000000000000000000000000000", 1).unwrap(),
            hex_to_bytes("64a59400000000000000000000000000", 1).unwrap(),
            hex_to_bytes("0d64a594000000000000000000000000", 1).unwrap(),
        ];
        let valid = [
            hex_to_bytes("00000000000000000000000000000100", 1).unwrap(),
            hex_to_bytes("94000000000000000000000000000001", 1).unwrap(),
            hex_to_bytes("a5940000000000000000000000000000", 1).unwrap(),
            hex_to_bytes("64a59400000000000000000000000000", 1).unwrap(),
        ];
        for (data, valid) in data.iter().zip(valid.iter()) {
            assert_eq!(r_reverse(data), *valid);
        }
    }

    #[test]
    fn test_l() {
        let data = [
            hex_to_bytes("64a59400000000000000000000000000", 1).unwrap(),
            hex_to_bytes("d456584dd0e3e84cc3166e4b7fa2890d", 1).unwrap(),
            hex_to_bytes("79d26221b87b584cd42fbc4ffea5de9a", 1).unwrap(),
            hex_to_bytes("0e93691a0cfc60408b7b68f66b513c13", 1).unwrap(),
        ];
        let valid = [
            hex_to_bytes("d456584dd0e3e84cc3166e4b7fa2890d", 1).unwrap(),
            hex_to_bytes("79d26221b87b584cd42fbc4ffea5de9a", 1).unwrap(),
            hex_to_bytes("0e93691a0cfc60408b7b68f66b513c13", 1).unwrap(),
            hex_to_bytes("e6a8094fee0aa204fd97bcb0b44b8580", 1).unwrap(),
        ];
        for (data, valid) in data.iter().zip(valid.iter()) {
            assert_eq!(l(data, r), *valid);
        }
    }

    #[test]
    fn test_l_reverse() {
        let data = [
            hex_to_bytes("d456584dd0e3e84cc3166e4b7fa2890d", 1).unwrap(),
            hex_to_bytes("79d26221b87b584cd42fbc4ffea5de9a", 1).unwrap(),
            hex_to_bytes("0e93691a0cfc60408b7b68f66b513c13", 1).unwrap(),
            hex_to_bytes("e6a8094fee0aa204fd97bcb0b44b8580", 1).unwrap(),
        ];
        let valid = [
            hex_to_bytes("64a59400000000000000000000000000", 1).unwrap(),
            hex_to_bytes("d456584dd0e3e84cc3166e4b7fa2890d", 1).unwrap(),
            hex_to_bytes("79d26221b87b584cd42fbc4ffea5de9a", 1).unwrap(),
            hex_to_bytes("0e93691a0cfc60408b7b68f66b513c13", 1).unwrap(),
        ];
        for (data, valid) in data.iter().zip(valid.iter()) {
            assert_eq!(l(data, r_reverse), *valid);
        }
    }

    #[test]
    fn test_x() {
        let k = hex_to_bytes("8899aabbccddeeff0011223344556677", 1).unwrap();
        let v = hex_to_bytes("e63bdcc9a09594475d369f2399d1f276", 1).unwrap();
        assert_eq!(x(&C[0], &k), v);
    }

    #[test]
    fn test_f() {
        let k1 = hex_to_bytes("8899aabbccddeeff0011223344556677", 1).unwrap();
        let k2 = hex_to_bytes("fedcba98765432100123456789abcdef", 1).unwrap();
        let (r1, r2) = f(&k1, &k2, &C[0]);
        let v1 = hex_to_bytes("c3d5fa01ebe36f7a9374427ad7ca8949", 1).unwrap();
        let v2 = hex_to_bytes("8899aabbccddeeff0011223344556677", 1).unwrap();
        assert_eq!(r1, v1);
        assert_eq!(r2, v2);
    }

    #[test]
    fn test_expand_key() {
        let key = hex_to_bytes("8899aabbccddeeff0011223344556677fedcba98765432100123456789abcdef", 1).unwrap();
        let validate = vec![
            hex_to_bytes("8899aabbccddeeff0011223344556677", 1).unwrap(),
            hex_to_bytes("fedcba98765432100123456789abcdef", 1).unwrap(),
            hex_to_bytes("db31485315694343228d6aef8cc78c44", 1).unwrap(),
            hex_to_bytes("3d4553d8e9cfec6815ebadc40a9ffd04", 1).unwrap(),
            hex_to_bytes("57646468c44a5e28d3e59246f429f1ac", 1).unwrap(),
            hex_to_bytes("bd079435165c6432b532e82834da581b", 1).unwrap(),
            hex_to_bytes("51e640757e8745de705727265a0098b1", 1).unwrap(),
            hex_to_bytes("5a7925017b9fdd3ed72a91a22286f984", 1).unwrap(),
            hex_to_bytes("bb44e25378c73123a5f32f73cdb6e517", 1).unwrap(),
            hex_to_bytes("72e9dd7416bcf45b755dbaa88e4a4043", 1).unwrap(),
        ];
        for (validator, result) in validate.iter().zip(expand_key(&key).iter()) {
            assert_eq!(*validator, *result);
        }
    }
    
    #[test]
    fn test_enc() {
        let key = hex_to_bytes("8899aabbccddeeff0011223344556677fedcba98765432100123456789abcdef", 32).unwrap();
        let phrase = hex_to_bytes("1122334455667700ffeeddccbbaa9988", 16).unwrap();
        let keys = expand_key(&key);
        let valid = hex_to_bytes("7f679d90bebc24305a468d42b9d4edcd", 16).unwrap();
        let result = enc(&phrase, &keys);
        assert_eq!(result, valid);
    }
    
    #[test]
    fn test_dec() {
        let key = hex_to_bytes("8899aabbccddeeff0011223344556677fedcba98765432100123456789abcdef", 32).unwrap();
        let phrase = hex_to_bytes("7f679d90bebc24305a468d42b9d4edcd", 16).unwrap();
        let keys = expand_key(&key);
        let valid = hex_to_bytes("1122334455667700ffeeddccbbaa9988", 16).unwrap();
        let result = dec(&phrase, &keys);
        assert_eq!(result, valid);
    }
    
    #[test]
    fn test_encrypt() {
        let key = "8899aabbccddeeff0011223344556677fedcba98765432100123456789abcdef";
        let text = "1122334455667700ffeeddccbbaa9988";
        let valid = "7f679d90bebc24305a468d42b9d4edcd";
        assert_eq!(&encrypt(text, key).unwrap(), valid);
    }
    
    #[test]
    fn test_decrypt() {
        let key = "8899aabbccddeeff0011223344556677fedcba98765432100123456789abcdef";
        let text = "7f679d90bebc24305a468d42b9d4edcd";
        let valid = "1122334455667700ffeeddccbbaa9988";
        assert_eq!(&decrypt(text, key).unwrap(), valid);
    }
}
